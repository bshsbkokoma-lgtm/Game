<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>เกม This or That</title>
    <!-- โหลด Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+Thai:wght@400;600;700&display=swap');
        :root {
            --primary-color: #4f46e5;
            --secondary-color: #8b5cf6;
            --bg-color: #f3f4f6;
            --card-color: #ffffff;
            --choice-color: #ecf0f1;
            --placeholder-color: #9ca3af; /* Gray for placeholder text */
        }
        body {
            font-family: 'Noto Sans Thai', 'Inter', sans-serif;
            background-color: var(--bg-color);
            min-height: 100vh;
        }
        .container-wrapper {
            max-width: 90%;
            margin: auto;
            padding: 1rem 0;
        }
        .game-card {
            background-color: var(--card-color);
            border-radius: 1.5rem;
            padding: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }
        .btn-primary {
            background-color: var(--primary-color);
            color: white;
            border-radius: 0.75rem;
            padding: 0.75rem 1.5rem;
            font-weight: 600;
            transition: background-color 0.2s;
            cursor: pointer;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #4338ca;
        }
        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .choice-button {
            width: 100%;
            min-height: 100px;
            background-color: var(--choice-color);
            color: #1f2937;
            border: 3px solid transparent;
            font-size: 1.5rem;
            font-weight: 700;
            padding: 1rem;
            border-radius: 1rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        /* Custom style for placeholder text */
        .choice-button.placeholder {
            color: var(--placeholder-color);
            background-color: #e5e7eb;
            font-size: 1.2rem;
            font-weight: 500;
        }

        .choice-button:hover:not(.chosen):not(.revealed):not(.placeholder) {
            background-color: #d1d5db;
        }
        .choice-button.chosen {
            background-color: var(--secondary-color);
            color: white;
            transform: scale(1.02);
        }
        .choice-button.winner {
            border-color: #10b981; /* Green border for match */
            background-color: #d1fae5;
        }
        .choice-button.loser {
            border-color: #f87171; /* Red border for no match */
            background-color: #fee2e2;
        }
    </style>
</head>
<body>

    <div class="container-wrapper flex flex-col items-center">
        <header class="text-center my-6">
            <h1 class="text-4xl font-extrabold text-gray-900 leading-tight">เลือก หรือ เลือก (This or That)</h1>
            
            <!-- NEW: Sign Out Button and Status in a flex container -->
            <div class="flex items-center justify-center mt-1 space-x-3">
                <p id="player-status" class="text-sm text-gray-500">รอการเชื่อมต่อ...</p>
                <button id="sign-out-btn" class="hidden text-xs px-2 py-1 bg-gray-500 hover:bg-gray-600 text-white rounded-md transition duration-150">
                    ออกจากระบบ
                </button>
            </div>
            
        </header>

        <!-- Main Content Area -->
        <div id="game-container" class="w-full lg:w-3/4 xl:w-1/2">

            <!-- Screen 1: Name Entry -->
            <div id="screen-name" class="game-card flex flex-col space-y-4">
                <h2 class="text-xl font-bold text-gray-800">1. ใส่ชื่อของคุณ</h2>
                <input type="text" id="player-name-input" placeholder="ชื่อเล่นของคุณ" maxlength="15"
                       class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-lg">
                <button id="set-name-btn" class="btn-primary">
                    บันทึกชื่อ & ดูห้องเกม
                </button>
            </div>

            <!-- Screen 2: Room Selection/Creation -->
            <div id="screen-rooms" class="game-card hidden space-y-6">
                <h2 class="text-xl font-bold text-gray-800">2. สร้างหรือเข้าร่วมห้อง</h2>

                <!-- Room Creation -->
                <button id="create-room-btn" class="btn-primary w-full">
                    สร้างห้องใหม่ (2 ผู้เล่น)
                </button>

                <!-- Available Rooms List -->
                <div class="space-y-3">
                    <h3 class="text-lg font-semibold text-gray-700">ห้องที่มีอยู่ (เห็นทั่วโลก)</h3>
                    <div id="rooms-list" class="bg-gray-50 p-4 rounded-xl border border-gray-200 min-h-[100px] max-h-96 overflow-y-auto space-y-2">
                        <!-- Rooms will be injected here -->
                        <p class="text-gray-500 italic" id="loading-rooms">กำลังโหลดห้อง...</p>
                    </div>
                </div>
            </div>

            <!-- Screen 3: Game Play & Status -->
            <div id="screen-game" class="game-card hidden space-y-6">

                <!-- User ID Display (Copyable) -->
                <div class="flex flex-col sm:flex-row justify-between items-center text-sm bg-gray-50 p-3 rounded-xl border border-gray-200">
                    <p class="font-semibold text-gray-700 mb-2 sm:mb-0">User ID (สำหรับอ้างอิง):</p>
                    <div class="flex items-center w-full sm:w-auto">
                        <span id="user-id-display" class="font-mono text-xs text-gray-500 truncate mr-2 w-32 sm:w-40">...</span>
                        <button id="copy-user-id-btn" class="text-xs px-2 py-1 bg-indigo-500 hover:bg-indigo-600 text-white rounded-md transition duration-150">
                            คัดลอก
                        </button>
                    </div>
                </div>

                <!-- Room Info and Players -->
                <div class="flex justify-between items-center pb-2 border-b border-gray-200">
                    <h2 class="text-xl font-bold text-gray-800">ห้อง ID: <span id="room-id-display" class="font-mono text-base text-gray-600">...</span></h2>
                    <button id="leave-room-btn" class="text-sm text-red-600 hover:text-red-800 font-medium">
                        ออกจากห้อง
                    </button>
                </div>

                <!-- Player Status -->
                <div id="player-scores" class="flex justify-around text-center">
                    <div id="player-1-info">
                        <p class="text-base font-medium text-gray-900" id="p1-name">รอผู้เล่น 1...</p>
                        <p class="text-3xl font-bold text-primary-color" id="p1-score">0</p>
                    </div>
                    <div class="text-4xl font-bold text-gray-400">VS</div>
                    <div id="player-2-info">
                        <p class="text-base font-medium text-gray-900" id="p2-name">รอผู้เล่น 2...</p>
                        <p class="text-3xl font-bold text-primary-color" id="p2-score">0</p>
                    </div>
                </div>

                <!-- Game Area -->
                <div id="game-area" class="space-y-4 pt-4 border-t border-gray-200">
                    <h3 id="current-round" class="text-center text-lg font-semibold text-gray-600">รอบที่: 0 / 10</h3>
                    <p id="game-status-message" class="text-center text-2xl font-bold text-gray-700 min-h-[50px]">
                        รอผู้เล่นคนที่สอง...
                    </p>

                    <div id="choice-buttons-wrapper" class="grid grid-cols-2 gap-4">
                        <button id="choice-1-btn" class="choice-button placeholder" disabled>รอเริ่มเกม...</button>
                        <button id="choice-2-btn" class="choice-button placeholder" disabled>รอเริ่มเกม...</button>
                    </div>

                    <!-- Next Round Button (Host only) -->
                    <div class="text-center pt-4">
                        <button id="next-round-btn" class="btn-primary hidden">
                            คำถามต่อไป (โฮสต์เท่านั้น)
                        </button>
                        <!-- Countdown timer removed as requested -->
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- Firebase Scripts (Must be type="module") -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"; // Optional: Uncomment for debugging

        // === CONFIGURATION PROVIDED BY THE USER (Using a placeholder config) ===
        const firebaseConfig = {
          apiKey: "AIzaSyAX4aPF1qDhGdVj5U6A2cIY64tar8ZGEIw",
          authDomain: "tort-63921.firebaseapp.com",
          projectId: "tort-63921",
          storageBucket: "tort-63921.firebasestorage.app",
          messagingSenderId: "1044890962097",
          appId: "1:1044890962097:web:b9c9a09733467408bdfa90",
          measurementId: "G-39517NH5QN"
        };
        // === END CONFIGURATION ===

        // Use global variables if available, otherwise use placeholders
        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.appId;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        const finalFirebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : firebaseConfig;

        // === Admin User ID for room deletion ===
        const ADMIN_USER_ID = 's4LGYYWdOWPcTtomT5vUdWJmDHF2';

        let app;
        let db;
        let auth;
        let userId = null;
        let userName = null;
        let currentRoomId = null;
        let roomSnapshotUnsubscribe = null;
        let roomsListUnsubscribe = null;

        // --- Game Data ---
        const MAX_PLAYERS = 2;
        const MAX_ROUNDS = 10;
        
        const ALL_QUESTIONS = [
            { t: 'แมว', h: 'หมา' }, // Cat or Dog
            { t: 'กาแฟ', h: 'ชา' }, // Coffee or Tea
            { t: 'ทะเล', h: 'ภูเขา' }, // Sea or Mountain
            { t: 'เช้า', h: 'กลางคืน' }, // Morning or Night
            { t: 'หนัง', h: 'ซีรีส์' }, // Movie or Series
            { t: 'เงิน', h: 'เวลา' }, // Money or Time
            { t: 'กินข้าวคนเดียว', h: 'ดูหนังคนเดียว' }, // Eat alone or Watch movie alone
            { t: 'ฝนตก', h: 'หิมะตก' }, // Rain or Snow
            { t: 'แชท', h: 'โทร' }, // Text or Call
            { t: 'เครื่องบิน', h: 'รถไฟ' }, // Plane or Train
            { t: 'หวาน', h: 'เผ็ด' }, // Sweet or Spicy
            { t: 'ตลก', h: 'โรแมนติก' }, // Comedy or Romance
            { t: 'เที่ยว', h: 'อยู่บ้าน' }, // Travel or Stay home
            { t: 'อ่านหนังสือ', h: 'ฟังเพลง' } // Read book or Listen to music
        ];

        // --- Utility Functions ---

        /**
         * Generates a unique collection path for public artifacts.
         * @param {string} collectionName
         */
        function getPublicCollectionPath(collectionName) {
            return `artifacts/${appId}/public/data/${collectionName}`;
        }

        /**
         * Generates a unique document path for a specific room.
         * @param {string} roomId
         */
        function getRoomDocPath(roomId) {
            return doc(db, getPublicCollectionPath('rooms'), roomId);
        }

        function showScreen(screenId) {
            const screens = ['screen-name', 'screen-rooms', 'screen-game'];
            screens.forEach(id => {
                document.getElementById(id).classList.add('hidden');
            });
            document.getElementById(screenId).classList.remove('hidden');
        }

        function showMessage(msg, color = 'text-gray-500') {
            const statusEl = document.getElementById('player-status');
            statusEl.textContent = msg;
            statusEl.className = `text-sm mt-1 font-medium ${color}`;
        }

        function createModal(message) {
             // Create a simple overlay modal for important messages
            const existingModal = document.getElementById('app-modal');
            if (existingModal) existingModal.remove();

            const modalHtml = `
                <div id="app-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 p-4">
                    <div class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full text-center">
                        <p class="text-lg font-semibold text-gray-800 mb-4">${message}</p>
                        <button onclick="document.getElementById('app-modal').remove()" class="btn-primary px-6">
                            ตกลง
                        </button>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        // --- Detailed Game Summary Modal ---
        function showGameOverSummary(room, p1, p2) {
            // Determine winner message
            const winnerMessage = p1.score > p2.score ? `${p1.name} ชนะ!` :
                                  p2.score > p1.score ? `${p2.name} ชนะ!` :
                                  'เสมอกัน!';

            const summaryHtml = room.history.map(entry => {
                const p1Chose = entry.p1Choice === 't' ? entry.question.t : entry.question.h;
                const p2Chose = entry.p2Choice === 't' ? entry.question.t : entry.question.h;
                const matchText = entry.match ?
                    `<span class="text-green-600 font-bold">เหมือนกันเยย!</span>` :
                    `<span class="text-red-600 font-bold">แตกต่างกัน</span>`;

                return `
                    <div class="p-3 border-b border-gray-100 last:border-b-0">
                        <p class="text-base font-semibold text-indigo-700">รอบที่ ${entry.round}: ${entry.question.t} หรือ ${entry.question.h}</p>
                        <div class="flex justify-between text-sm mt-1">
                            <p class="w-1/2 truncate pr-2"><span class="font-medium">${entry.p1Name}:</span> ${p1Chose}</p>
                            <p class="w-1/2 truncate pl-2"><span class="font-medium">${entry.p2Name}:</span> ${p2Chose}</p>
                        </div>
                        <p class="text-center text-xs mt-2">${matchText}</p>
                    </div>
                `;
            }).join('');


            // Create a detailed overlay modal
            const existingModal = document.getElementById('app-modal');
            if (existingModal) existingModal.remove();

            const modalHtml = `
                <div id="app-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 p-4">
                    <div class="bg-white p-6 rounded-xl shadow-2xl max-w-lg w-full text-center max-h-[90vh] flex flex-col">
                        <h3 class="text-2xl font-extrabold text-primary-color mb-2">เกมจบแล้ว!</h3>
                        <p class="text-xl font-bold text-gray-800 mb-4">${winnerMessage} (${p1.score} - ${p2.score})</p>

                        <h4 class="text-lg font-semibold text-gray-700 mb-3 border-t pt-3">สรุปผลการเลือกแต่ละรอบ</h4>

                        <div class="overflow-y-auto bg-gray-50 rounded-lg border border-gray-200 flex-grow mb-4">
                            ${room.history && room.history.length > 0 ? summaryHtml : '<p class="text-gray-500 italic p-4">ไม่มีประวัติการเล่น</p>'}
                        </div>

                        <button onclick="document.getElementById('app-modal').remove()" class="btn-primary px-6">
                            ตกลง / ปิดสรุป
                        </button>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        // --- Copy to Clipboard Function ---
        function copyUserIdToClipboard(text) {
            const tempInput = document.createElement("textarea");
            tempInput.value = text;
            document.body.appendChild(tempInput);
            tempInput.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showMessage('คัดลอก User ID สำเร็จ!', 'text-green-600');
                } else {
                    createModal('คัดลอกไม่สำเร็จ. กรุณาลองใหม่');
                }
            } catch (err) {
                createModal('ไม่สามารถคัดลอกได้: ' + err);
            }
            document.body.removeChild(tempInput);
        }

        // --- NEW: Sign Out Logic ---
        async function handleSignOut() {
            // 1. Clean up Firestore data (remove player from room/delete room if alone)
            if (currentRoomId) {
                // Pass false so it doesn't try to navigate/setup new listeners,
                // as we are about to sign out which triggers auth listener navigation.
                await leaveRoom(false);
            }

            // 2. Clear local storage and state
            localStorage.removeItem('player-name');
            localStorage.removeItem('current-room-id');
            userName = null;
            currentRoomId = null;
            userId = null; // Important: Clear the ID before sign out

            // 3. Stop rooms list listener if active
            if (roomsListUnsubscribe) {
                roomsListUnsubscribe();
                roomsListUnsubscribe = null;
            }

            // 4. Sign out from Firebase Auth
            try {
                await signOut(auth);
                showMessage('ออกจากระบบเรียบร้อยแล้ว', 'text-blue-600');
                // The onAuthStateChanged listener will handle screen transition to 'screen-name'
            } catch (error) {
                console.error("Error signing out:", error);
                createModal(`ออกจากระบบไม่สำเร็จ: ${error.message}`);
            }
        }


        // --- Firebase Initialization and Auth ---

        async function initFirebase() {
            // setLogLevel('Debug'); // Uncomment to debug firestore
            try {
                if (Object.keys(finalFirebaseConfig).length === 0 || !finalFirebaseConfig.apiKey) {
                    showMessage("ข้อผิดพลาด: ไม่พบการตั้งค่า Firebase.", 'text-red-600');
                    return;
                }
                app = initializeApp(finalFirebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // 1. Authenticate user
                // (Initial sign in logic is now mostly handled by onAuthStateChanged)
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }


                // 2. Set up Auth listener
                onAuthStateChanged(auth, (user) => {
                    const signOutBtn = document.getElementById('sign-out-btn');
                    if (user) {
                        userId = user.uid;
                        // Display User ID immediately
                        document.getElementById('user-id-display').textContent = userId;
                        signOutBtn.classList.remove('hidden'); // Show button

                        // Check if name is already set
                        const storedName = localStorage.getItem('player-name');
                        if (storedName) {
                            userName = storedName;
                            document.getElementById('player-name-input').value = userName;
                            showMessage(`เข้าสู่ระบบแล้วในชื่อ: ${userName}`, 'text-green-600');
                            startApp();
                        } else {
                            showMessage("กรุณาใส่ชื่อของคุณเพื่อเริ่ม", 'text-yellow-600');
                            showScreen('screen-name');
                        }
                    } else {
                        // User is signed out
                        userId = null;
                        signOutBtn.classList.add('hidden'); // Hide button
                        showMessage("ไม่ได้เข้าสู่ระบบ", 'text-red-600');
                        
                        // Clear any lingering listeners if they weren't cleared by leaveRoom
                        if (roomSnapshotUnsubscribe) { roomSnapshotUnsubscribe(); roomSnapshotUnsubscribe = null; }
                        if (roomsListUnsubscribe) { roomsListUnsubscribe(); roomsListUnsubscribe = null; }
                        
                        showScreen('screen-name');
                    }
                });

            } catch (error) {
                console.error("Firebase init/auth error:", error);
                showMessage(`ข้อผิดพลาดในการเริ่มต้นระบบ: ${error.message}`, 'text-red-600');
            }
        }

        // --- Room Management (Screen 2) ---

        function startApp() {
            // Check if player was in a room before
            const storedRoomId = localStorage.getItem('current-room-id');
            if (storedRoomId) {
                currentRoomId = storedRoomId;
                joinRoom(currentRoomId, userName, true); // Attempt to rejoin
            } else {
                showScreen('screen-rooms');
                setupRoomsListListener();
            }
        }
        
        // --- Admin Delete Logic ---
        async function adminDeleteRoom(roomId) {
            if (userId !== ADMIN_USER_ID) return;
            const roomRef = getRoomDocPath(roomId);
            try {
                await deleteDoc(roomRef);
                // The onSnapshot listener handles UI update
                showMessage(`[Admin] ลบห้อง ${roomId.substring(0, 4)} สำเร็จ`, 'text-red-600');
            } catch (error) {
                createModal(`[Admin] ลบห้องไม่สำเร็จ: ${error.message}`);
            }
        }

        function setupRoomsListListener() {
            if (roomsListUnsubscribe) roomsListUnsubscribe();

            const roomsCol = collection(db, getPublicCollectionPath('rooms'));
            // Query for rooms that are WAITING, CHOOSING, or REVEAL and not explicitly finished
            const q = query(roomsCol, where('status', 'in', ['WAITING', 'CHOOSING', 'REVEAL']));
            const isAdmin = userId === ADMIN_USER_ID;

            roomsListUnsubscribe = onSnapshot(q, (snapshot) => {
                const listEl = document.getElementById('rooms-list');
                listEl.innerHTML = '';
                let hasRooms = false;

                snapshot.docs.forEach(docSnap => {
                    const data = docSnap.data();
                    const playersCount = Object.keys(data.players || {}).length;

                    // Only show rooms that are not full or are currently in game
                    if (playersCount < MAX_PLAYERS || data.status !== 'WAITING') {
                        hasRooms = true;
                        const roomName = data.hostName ? `${data.hostName}'s Room (${data.status})` : `Room ${docSnap.id.substring(0, 4)} (${data.status})`;

                        listEl.insertAdjacentHTML('beforeend', `
                            <div class="flex justify-between items-center p-3 bg-white rounded-lg border border-indigo-200">
                                <p class="text-base font-medium text-gray-800 truncate">${roomName}</p>
                                <div class="flex flex-wrap items-center space-x-3">
                                    <span class="text-sm font-semibold text-primary-color">${playersCount}/${MAX_PLAYERS}</span>
                                    <button data-room-id="${docSnap.id}" class="btn-join text-sm px-3 py-1 bg-primary-color hover:bg-indigo-700 text-white rounded-md mb-1 sm:mb-0">
                                        เข้าร่วม
                                    </button>
                                    ${isAdmin ? `<button data-room-id="${docSnap.id}" class="btn-delete text-sm px-3 py-1 bg-red-600 hover:bg-red-700 text-white rounded-md mb-1 sm:mb-0">ลบ</button>` : ''}
                                </div>
                            </div>
                        `);
                    }
                });

                if (!hasRooms) {
                    listEl.innerHTML = '<p class="text-gray-500 italic text-center">ยังไม่มีห้องเกมว่าง สร้างห้องใหม่ได้เลย!</p>';
                }

                // Add event listeners to new join and delete buttons
                listEl.querySelectorAll('.btn-join').forEach(button => {
                    button.onclick = (e) => {
                        const roomId = e.target.getAttribute('data-room-id');
                        joinRoom(roomId, userName);
                    };
                });
                 if (isAdmin) {
                    listEl.querySelectorAll('.btn-delete').forEach(button => {
                        button.onclick = (e) => {
                            const roomId = e.target.getAttribute('data-room-id');
                            adminDeleteRoom(roomId);
                        };
                    });
                }
            }, (error) => {
                console.error("Error fetching rooms list:", error);
                document.getElementById('rooms-list').innerHTML = '<p class="text-red-500 italic text-center">ข้อผิดพลาดในการโหลดห้อง</p>';
            });
        }

        async function createRoom() {
            if (!userId || !userName) return createModal('กรุณาใส่ชื่อผู้เล่นก่อน!');

            // 1. Create initial room data
            const initialRoomData = {
                hostId: userId,
                hostName: userName,
                status: 'WAITING',
                questionIndex: 0,
                currentQuestion: null, // Start with no question to avoid spoilers
                history: [], // To store past round details for summary
                players: {
                    [userId]: { name: userName, choice: null, score: 0, isHost: true }
                },
                createdAt: new Date().getTime(),
            };

            const roomsCol = collection(db, getPublicCollectionPath('rooms'));
            try {
                const docRef = await addDoc(roomsCol, initialRoomData);
                currentRoomId = docRef.id;
                localStorage.setItem('current-room-id', currentRoomId);
                showMessage(`สร้างห้อง ${currentRoomId.substring(0, 4)} สำเร็จ`, 'text-indigo-600');
                showScreen('screen-game');
                setupRoomGameListener(currentRoomId);
            } catch (error) {
                console.error("Error creating room:", error);
                createModal(`สร้างห้องไม่สำเร็จ: ${error.message}`);
            }
        }

        async function joinRoom(roomId, playerName, isRejoin = false) {
            if (!userId || !playerName) return createModal('กรุณาใส่ชื่อผู้เล่นก่อน!');
            if (roomsListUnsubscribe) roomsListUnsubscribe(); // Stop listening to room list

            const roomRef = getRoomDocPath(roomId);

            try {
                const docSnap = await getDoc(roomRef);
                if (!docSnap.exists()) {
                    localStorage.removeItem('current-room-id');
                    return createModal('ห้องเกมนี้ไม่มีอยู่แล้ว');
                }

                const roomData = docSnap.data();
                const players = roomData.players || {};
                const playersCount = Object.keys(players).length;

                // Check if already in the room (rejoining)
                if (players.hasOwnProperty(userId)) {
                    currentRoomId = roomId;
                    localStorage.setItem('current-room-id', currentRoomId);
                    showMessage(`กลับเข้าร่วมห้อง ${roomId.substring(0, 4)}`, 'text-indigo-600');
                    showScreen('screen-game');
                    setupRoomGameListener(currentRoomId);
                    return;
                }

                // Check if room is full
                if (playersCount >= MAX_PLAYERS) {
                    localStorage.removeItem('current-room-id');
                    return createModal('ห้องเต็มแล้ว! กรุณาเลือกห้องอื่น');
                }

                // Join the room
                const newPlayer = { name: playerName, choice: null, score: 0, isHost: false };

                await updateDoc(roomRef, {
                    [`players.${userId}`]: newPlayer
                });

                currentRoomId = roomId;
                localStorage.setItem('current-room-id', currentRoomId);
                showMessage(`เข้าร่วมห้อง ${roomId.substring(0, 4)} สำเร็จ`, 'text-indigo-600');
                showScreen('screen-game');
                setupRoomGameListener(currentRoomId);

            } catch (error) {
                console.error("Error joining room:", error);
                createModal(`เข้าร่วมห้องไม่สำเร็จ: ${error.message}`);
                localStorage.removeItem('current-room-id');
                showScreen('screen-rooms');
                setupRoomsListListener();
            }
        }

        // --- Game Logic (Screen 3) ---

        function setupRoomGameListener(roomId) {
            if (roomSnapshotUnsubscribe) roomSnapshotUnsubscribe();

            const roomRef = getRoomDocPath(roomId);

            roomSnapshotUnsubscribe = onSnapshot(roomRef, (docSnap) => {
                if (!docSnap.exists()) {
                    createModal('ห้องเกมถูกลบ/ปิดแล้ว! กลับสู่หน้าเลือกห้อง');
                    leaveRoom(true); // Navigate back to rooms screen
                    return;
                }
                updateGameUI(docSnap.data());
            }, (error) => {
                console.error("Error listening to room:", error);
                createModal(`ข้อผิดพลาดในการซิงค์เกม: ${error.message}`);
            });
        }

        function getNextQuestion(index) {
            // Use index modulo array length to cycle questions
            const nextIndex = (index - 1) % ALL_QUESTIONS.length;
            return ALL_QUESTIONS[nextIndex];
        }

        function updateGameUI(room) {
            const players = Object.values(room.players || {});
            const playerMap = room.players || {};
            const isHost = room.hostId === userId;
            const myPlayer = playerMap[userId] || {};

            // 1. Update Room Info
            document.getElementById('room-id-display').textContent = room.hostName ? room.hostName : currentRoomId.substring(0, 4);
            document.getElementById('current-round').textContent = `รอบที่: ${room.questionIndex} / ${MAX_ROUNDS}`;

            // 2. Update Player Scores/Names
            const pIds = Object.keys(playerMap);
            // Ensure p1 is always the host for consistent display
            const p1Id = room.hostId;
            const p2Id = pIds.find(id => id !== p1Id);

            const p1 = playerMap[p1Id] || { name: 'รอผู้เล่น 1...', score: 0 };
            const p2 = p2Id ? (playerMap[p2Id] || { name: 'รอผู้เล่น 2...', score: 0 }) : { name: 'รอผู้เล่น 2...', score: 0 };

            document.getElementById('p1-name').textContent = `${p1.name} ${p1Id === userId ? '(คุณ)' : ''}`;
            document.getElementById('p1-score').textContent = p1.score;
            document.getElementById('p2-name').textContent = `${p2.name} ${p2Id === userId ? '(คุณ)' : ''}`;
            document.getElementById('p2-score').textContent = p2.score;

            const choice1Btn = document.getElementById('choice-1-btn');
            const choice2Btn = document.getElementById('choice-2-btn');

            // Reset button classes
            choice1Btn.className = 'choice-button';
            choice2Btn.className = 'choice-button';
            choice1Btn.disabled = true;
            choice2Btn.disabled = true;

            // Set button text and status based on question
            if (room.status === 'WAITING' || !room.currentQuestion) {
                choice1Btn.textContent = 'รอเริ่มเกม...';
                choice2Btn.textContent = 'รอเริ่มเกม...';
                choice1Btn.classList.add('placeholder');
                choice2Btn.classList.add('placeholder');
            } else {
                choice1Btn.textContent = room.currentQuestion.t;
                choice2Btn.textContent = room.currentQuestion.h;
                choice1Btn.classList.remove('placeholder');
                choice2Btn.classList.remove('placeholder');
            }

            // 3. Handle Game Status
            const allChosen = players.length === MAX_PLAYERS && players.every(p => p.choice !== null);

            document.getElementById('next-round-btn').classList.add('hidden');
            document.getElementById('game-status-message').className = 'text-center text-2xl font-bold text-gray-700 min-h-[50px]';

            if (room.questionIndex > MAX_ROUNDS) {
                room.status = 'GAME_OVER';
            }

            switch (room.status) {
                case 'WAITING':
                    document.getElementById('game-status-message').textContent = players.length < MAX_PLAYERS
                        ? 'กำลังรอผู้เล่นคนที่สอง...'
                        : 'ผู้เล่นครบแล้ว! โฮสต์สามารถกดเริ่มเกมได้';
                    if (players.length === MAX_PLAYERS && isHost) {
                        document.getElementById('next-round-btn').textContent = 'เริ่มเกม!';
                        document.getElementById('next-round-btn').classList.remove('hidden');
                        document.getElementById('next-round-btn').disabled = false;
                    }
                    break;

                case 'CHOOSING':
                    document.getElementById('game-status-message').textContent = 'เลือกสิ่งที่คุณชอบมากกว่า!';

                    if (myPlayer.choice === null) {
                        choice1Btn.disabled = false;
                        choice2Btn.disabled = false;
                    } else {
                        document.getElementById('game-status-message').textContent = 'รอผู้เล่นคนอื่นเลือก...';
                        if (myPlayer.choice === 't') choice1Btn.classList.add('chosen');
                        if (myPlayer.choice === 'h') choice2Btn.classList.add('chosen');
                    }

                    // *** AUTOMATIC TRANSITION LOGIC ***
                    if (allChosen && isHost) {
                        // Host automatically advances to REVEAL state
                        const roomRef = getRoomDocPath(currentRoomId);
                        updateDoc(roomRef, { status: 'REVEAL' });
                    }
                    // *** END AUTOMATIC TRANSITION ***
                    break;

                case 'REVEAL':
                    document.getElementById('game-status-message').textContent = 'ผลลัพธ์เปิดเผยแล้ว!';
                    document.getElementById('game-status-message').classList.add('text-secondary-color');

                    // Apply styles based on match
                    if (p1.choice === p2.choice) {
                        document.getElementById('game-status-message').textContent = 'ว้าว! เลือกเหมือนกันเลย!';
                        if (myPlayer.choice === 't') choice1Btn.classList.add('winner');
                        if (myPlayer.choice === 'h') choice2Btn.classList.add('winner');
                    } else {
                        document.getElementById('game-status-message').textContent = 'เลือกแตกต่างกัน!';
                        if (myPlayer.choice === 't') choice1Btn.classList.add('loser');
                        if (myPlayer.choice === 'h') choice2Btn.classList.add('loser');
                    }

                    // Show next round button (IMMEDIATELY ENABLED as requested)
                    if (isHost) {
                        document.getElementById('next-round-btn').textContent = 'คำถามต่อไป';
                        document.getElementById('next-round-btn').classList.remove('hidden');
                        document.getElementById('next-round-btn').disabled = false;
                    }
                    break;

                case 'GAME_OVER':
                    // Show detailed summary modal
                    showGameOverSummary(room, p1, p2);

                    document.getElementById('game-status-message').textContent = 'จบเกมแล้ว!';
                    document.getElementById('game-status-message').classList.add('text-red-600');

                    if (isHost) {
                        document.getElementById('next-round-btn').textContent = 'เริ่มเกมใหม่';
                        document.getElementById('next-round-btn').classList.remove('hidden');
                        document.getElementById('next-round-btn').disabled = false;
                        document.getElementById('next-round-btn').onclick = () => resetRoom(room);
                    }
                    break;
            }
        }

        async function makeChoice(choice) {
            if (!currentRoomId || !userId || !userName) return;

            const roomRef = getRoomDocPath(currentRoomId);
            const choiceBtn = choice === 't' ? document.getElementById('choice-1-btn') : document.getElementById('choice-2-btn');

            // Disable buttons and mark selection
            document.getElementById('choice-1-btn').disabled = true;
            document.getElementById('choice-2-btn').disabled = true;
            choiceBtn.classList.add('chosen');

            try {
                // Update player's choice in the room
                await updateDoc(roomRef, {
                    [`players.${userId}.choice`]: choice
                });

                showMessage('บันทึกการเลือกแล้ว! รอผู้เล่นคนอื่น...', 'text-orange-600');
            } catch (error) {
                console.error("Error making choice:", error);
                createModal(`บันทึกการเลือกไม่สำเร็จ: ${error.message}`);
            }
        }

        async function nextRound() {
            if (!currentRoomId || !userId) return;

            const roomRef = getRoomDocPath(currentRoomId);
            const docSnap = await getDoc(roomRef);
            if (!docSnap.exists() || docSnap.data().hostId !== userId) return; // Only host can advance

            const room = docSnap.data();
            let newStatus = 'CHOOSING';
            let newIndex = room.questionIndex;
            let newPlayers = room.players;
            let newQuestion = room.currentQuestion; // Default to existing question
            let newHistory = room.history || [];

            // 1. Handle transition from REVEAL or WAITING
            if (room.status === 'REVEAL') {
                const pIds = Object.keys(newPlayers);
                const p1Id = room.hostId;
                const p2Id = pIds.find(id => id !== p1Id);

                // Check if p2 exists before proceeding to calculate score/history
                if (p2Id) {
                    const p1 = newPlayers[p1Id];
                    const p2 = newPlayers[p2Id];

                    // --- Capture History ---
                    const historyEntry = {
                        round: room.questionIndex,
                        question: room.currentQuestion,
                        p1Choice: p1.choice,
                        p2Choice: p2.choice,
                        p1Name: p1.name,
                        p2Name: p2.name,
                        match: p1.choice === p2.choice
                    };
                    newHistory = [...newHistory, historyEntry];
                    // -----------------------

                    // Calculate Score
                    if (historyEntry.match) {
                        // Match! Both get a point
                        newPlayers[p1Id].score += 1;
                        newPlayers[p2Id].score += 1;
                    }
                }

                newIndex += 1; // Advance round index

                if (newIndex > MAX_ROUNDS) {
                    newStatus = 'GAME_OVER';
                }

                // Get the next question (or null if game over)
                newQuestion = newStatus === 'GAME_OVER' ? null : getNextQuestion(newIndex);

            } else if (room.status === 'WAITING') {
                 // Transition from WAITING to CHOOSING (Start Game)
                 if (Object.keys(room.players).length < MAX_PLAYERS) {
                     createModal('ยังไม่มีผู้เล่นครบ 2 คน!');
                     return;
                 }
                 newIndex = 1; // Start the first round
                 newQuestion = getNextQuestion(newIndex); // Get the first question
                 newStatus = 'CHOOSING';
            } else if (room.status === 'CHOOSING') {
                // If somehow host manually clicks next in CHOOSING, ignore or force transition
                return;
            }

            // 2. Reset Choices (applies to both transitions)
            for (const id in newPlayers) {
                newPlayers[id].choice = null;
            }

            // 3. Update Firestore
            try {
                await updateDoc(roomRef, {
                    status: newStatus,
                    questionIndex: newIndex,
                    currentQuestion: newQuestion,
                    players: newPlayers,
                    history: newHistory // Update history array
                });
            } catch (error) {
                console.error("Error advancing round:", error);
                createModal(`ไปรอบต่อไปไม่สำเร็จ: ${error.message}`);
            }
        }

        async function resetRoom(room) {
             if (!currentRoomId || room.hostId !== userId) return; // Only host can reset
             const roomRef = getRoomDocPath(currentRoomId);

             let newPlayers = {};
             for (const id in room.players) {
                 newPlayers[id] = { ...room.players[id], score: 0, choice: null };
             }

             const newQuestion = getNextQuestion(1);

             try {
                 await updateDoc(roomRef, {
                     status: 'CHOOSING',
                     questionIndex: 1,
                     currentQuestion: newQuestion,
                     players: newPlayers,
                     history: [] // Clear history on reset
                 });
             } catch (error) {
                 console.error("Error resetting room:", error);
                 createModal(`รีเซ็ตห้องไม่สำเร็จ: ${error.message}`);
             }
        }

        async function leaveRoom(navigate = true) {
            if (roomSnapshotUnsubscribe) {
                roomSnapshotUnsubscribe();
                roomSnapshotUnsubscribe = null;
            }

            if (currentRoomId && userId) {
                const roomRef = getRoomDocPath(currentRoomId);

                try {
                    const docSnap = await getDoc(roomRef);
                    if (!docSnap.exists()) {
                        console.warn("Room already gone.");
                    } else {
                        const roomData = docSnap.data();
                        const playersCount = Object.keys(roomData.players || {}).length;

                        // LOGIC FOR AUTOMATIC ROOM DELETION
                        if (playersCount === 1 && roomData.players.hasOwnProperty(userId)) {
                            // If only one player left (the current user), delete the room entirely.
                            await deleteDoc(roomRef);
                            if (navigate) { showMessage(`ห้อง ${currentRoomId.substring(0, 4)} ถูกลบแล้ว`, 'text-red-600'); }
                        } else if (playersCount > 1 && roomData.players.hasOwnProperty(userId)) {
                            // If other players remain, just remove the current player.
                            await updateDoc(roomRef, {
                                [`players.${userId}`]: deleteField()
                            });
                        }
                    }
                } catch (e) {
                    console.error("Error leaving/deleting room:", e);
                }
            }

            currentRoomId = null;
            localStorage.removeItem('current-room-id');
            if (navigate) { showMessage(`ออกจากห้องเกมแล้ว`, 'text-blue-600'); }

            // If navigate is true, we transition back to the rooms list
            if (navigate) {
                showScreen('screen-rooms');
                setupRoomsListListener();
            }
            // If navigate is false (called before sign out), we just clean up Firestore state.
        }

        // --- Event Listeners ---

        document.getElementById('set-name-btn').onclick = () => {
            const inputName = document.getElementById('player-name-input').value.trim();
            if (inputName.length < 2 || inputName.length > 15) {
                createModal('กรุณาใส่ชื่อระหว่าง 2-15 ตัวอักษร');
                return;
            }
            userName = inputName;
            localStorage.setItem('player-name', userName);
            showMessage(`บันทึกชื่อ: ${userName}`, 'text-green-600');
            startApp();
        };

        // Event listener for copying User ID
        document.getElementById('copy-user-id-btn').onclick = () => {
            const idToCopy = document.getElementById('user-id-display').textContent;
            if (idToCopy && idToCopy !== '...') {
                copyUserIdToClipboard(idToCopy);
            }
        };

        document.getElementById('create-room-btn').onclick = createRoom;

        document.getElementById('leave-room-btn').onclick = () => {
             // Use a custom modal for confirmation
             const message = 'แน่ใจหรือไม่ว่าต้องการออกจากห้อง? หากคุณเป็นคนสุดท้าย ห้องจะถูกลบทิ้ง';
             const existingModal = document.getElementById('app-modal');
             if (existingModal) existingModal.remove();

             const modalHtml = `
                 <div id="app-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 p-4">
                     <div class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full text-center">
                         <p class="text-lg font-semibold text-gray-800 mb-4">${message}</p>
                         <button id="cancel-leave-btn" class="btn-primary px-6 bg-gray-500 hover:bg-gray-600">
                             ยกเลิก
                         </button>
                         <button id="confirm-leave-btn" class="btn-primary px-6 ml-3 bg-red-600 hover:bg-red-700">
                             ยืนยันการออก
                         </button>
                     </div>
                 </div>
             `;
             document.body.insertAdjacentHTML('beforeend', modalHtml);

             document.getElementById('cancel-leave-btn').onclick = () => document.getElementById('app-modal').remove();
             document.getElementById('confirm-leave-btn').onclick = () => {
                 document.getElementById('app-modal').remove();
                 leaveRoom(true); // Navigate back to room selection
             };
        };


        document.getElementById('choice-1-btn').onclick = () => {
            if (document.getElementById('choice-1-btn').classList.contains('placeholder')) return;
            makeChoice('t');
        };
        document.getElementById('choice-2-btn').onclick = () => {
            if (document.getElementById('choice-2-btn').classList.contains('placeholder')) return;
            makeChoice('h');
        };

        // Host function for starting/advancing round
        document.getElementById('next-round-btn').onclick = nextRound;

        // NEW: Sign Out Button Listener
        document.getElementById('sign-out-btn').onclick = handleSignOut;


        // Start the application flow
        initFirebase();
    </script>
</body>
</html>
